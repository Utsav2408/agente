from datetime import date
from typing import List, Optional
from bson import ObjectId
from pymongo.collection import Collection

from config.mongo_connect import mongo
from constant.constant import EXAM_COLLECTION, EXAM_DB
from mongo_ops.utils import _to_doc
from pydantic_models.exam_models import ExamData, ExamStat, QuestionAnswerData

# ---------------------------------------------------------------------------
# Mongo connection (open once, reuse everywhere)
# ---------------------------------------------------------------------------
_exam_col: Collection = mongo.get_connection()[EXAM_DB][EXAM_COLLECTION]


# ---------------------------------------------------------------------------
# CRUD
# ---------------------------------------------------------------------------


def add_exam(exam: ExamData) -> ObjectId:
    """
    Insert a new exam document.

    Returns
    -------
    bson.ObjectId
        `_id` generated by MongoDB.
    """
    res = _exam_col.insert_one(_to_doc(exam))
    return res.inserted_id


def get_exam_by_id(exam_id: str) -> Optional[ExamData]:
    """
    Fetch an exam by its unique `exam_id`.
    """
    doc = _exam_col.find_one({"exam_id": exam_id}, {"_id": 0})
    return ExamData.model_validate(doc) if doc else None


def get_exam_by_keys(
    exam_type: str,
    course_id: str,
) -> Optional[ExamData]:
    """
    Fetch an exam using the composite key (`exam_type`, `course_id`).
    """
    doc = _exam_col.find_one(
        {"exam_type": exam_type, "course_id": course_id},
        {"_id": 0},
    )
    return ExamData.model_validate(doc) if doc else None


def fetch_stat_for_exam(exam_id: str) -> Optional[ExamStat]:
    """
    Fetch an exam's stat by its unique `exam_id`.
    """
    doc = _exam_col.find_one({"exam_id": exam_id}, {"_id": 0})
    return ExamStat.model_validate(doc.get("stats")) if doc else None


def update_answer_key(grade: str, exam_type: str, course_name: str, question_answer_pairs: List[QuestionAnswerData]) -> int:
    result = _exam_col.update_one(
        {"exam_id": f"{grade}:{course_name}:{exam_type}"},
        {"$set": {"question_answer": [qa_pair.model_dump() for qa_pair in question_answer_pairs]}}
    )
    return result.modified_count


def submit_answer_key(grade: str, exam_type: str, course_name: str) -> int:
    result = _exam_col.update_one(
        {"exam_id": f"{grade}:{course_name}:{exam_type}"},
        {"$set": {"explored": True}}
    )
    return result.modified_count


def fetch_questions(grade: str, exam_type: str, course_name: str,) -> List[str]:
    questions = []
    doc = _exam_col.find_one({"exam_id": f"{grade}:{course_name}:{exam_type}"}, {"_id": 0})
    for q_a_pair in doc.get("question_answer", []):
        questions.append(q_a_pair["question"])
    return questions


def fetch_question_answer(grade: str, exam_type: str, course_name: str,) -> List[QuestionAnswerData]:
    doc = _exam_col.find_one({"exam_id": f"{grade}:{course_name}:{exam_type}"}, {"_id": 0})
    return doc.get("question_answer")